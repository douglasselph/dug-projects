{
    "version": "1.0",
    "rules": {
        "law_of_demeter": {
            "pattern": "(?!.*?\\.[^\\s]*\\.[^\\s]*\\.[^\\s]*)",
            "description": "Methods should only call methods on immediate dependencies (Law of Demeter). Avoid chains of method calls like 'a.b.c.d()'",
            "examples": {
                "violations": [
                    "state.cardsInHand.cards.contains(card)",
                    "player.getState().getHand().getCards()"
                ],
                "compliant": [
                    "state.hasCardInHand(card)",
                    "hand.containsCard(card)"
                ]
            },
            "applies_to": ["**/*.kt"],
            "rationale": "Reduces coupling, improves maintainability, and follows the principle of least knowledge"
        },
        "test_naming_convention": {
            "pattern": "^[a-zA-Z]+_[a-zA-Z]+[a-zA-Z0-9]*_[a-zA-Z]+[a-zA-Z0-9]*$",
            "description": "Test function names should follow the pattern: function_condition_expectedResult",
            "examples": [
                "get_whenStackExists_returnsCorrectCards",
                "empty_whenNewMarketCreated_returnsEmptyStacks",
                "getAllCards_withPopulatedMarket_returnsAllCards"
            ],
            "applies_to": ["**/*Test.kt"],
            "test_function_identifiers": ["@Test"]
        },
        "test_structure": {
            "pattern": "(?s).*// Arrange.*// Act.*// Assert.*",
            "description": "Test functions should follow the Arrange/Act/Assert pattern with clear section comments",
            "examples": [
                "// Arrange\nval input = ...\n\n// Act\nval result = ...\n\n// Assert\nassertEquals(...)",
                "// Arrange - Using mock data\n...\n// Act & Assert\nassertThrows..."
            ],
            "applies_to": ["**/*Test.kt"],
            "test_function_identifiers": ["@Test"]
        },
        "test_string_constants": {
            "pattern": "(?!.*companion\\s*object\\s*\\{[^}]*private\\s+const\\s+val\\s+[A-Z_]+\\s*=\\s*\"[^\"]+\"[^}]*\\}).*\"[^\"]+\"",
            "description": "String literals in test files should be defined as constants in the companion object",
            "examples": {
                "violations": [
                    "assertEquals(\"Card Name\", card.name)",
                    "getCard(\"Invalid Card\")"
                ],
                "compliant": [
                    "assertEquals(CARD_NAME, card.name)",
                    "getCard(INVALID_CARD)"
                ]
            },
            "applies_to": ["**/*Test.kt"],
            "rationale": "Improves maintainability and reduces the risk of typos in test strings"
        },
        "die_creation": {
            "pattern": "private\\s+val\\s+sampleDie\\s*=\\s*SampleDie\\(\\)\\s*\\n\\s*private\\s+val\\s+d\\d+\\s*:\\s*Die\\s*=\\s*sampleDie\\.d\\d+",
            "description": "Dice should be created using SampleDie",
            "examples": {
                "compliant": [
                    "private val sampleDie = SampleDie()\nprivate val d6: Die = sampleDie.d6",
                    "private val sampleDie = SampleDie()\nprivate val d6: Die = sampleDie.d6.adjustTo(3)"
                ],
                "violations": [
                    "private val d6 = Die(6)",
                    "private val d6 = mockk<Die>(relaxed = true)"
                ]
            }
        },
        "mockk_just_runs": {
            "pattern": "just\\s+runs",
            "description": "Use 'just Runs' (capital R) instead of 'just runs' in MockK tests",
            "examples": {
                "violations": [
                    "every { mock.method() } just runs",
                    "every { mock.voidMethod() } just runs"
                ],
                "compliant": [
                    "every { mock.method() } just Runs",
                    "every { mock.voidMethod() } just Runs"
                ]
            },
            "applies_to": ["**/*Test.kt"],
            "rationale": "Ensures correct capitalization for MockK's just Runs operator"
        },
        "test_mock_conventions": {
            "description": "Conventions for setting up mocks and test dependencies",
            "rules": {
                "mock_declaration": {
                    "pattern": "private\\s+val\\s+mock[A-Z]\\w+\\s*=\\s*mockk<[^>]+>\\(relaxed\\s*=\\s*true\\)",
                    "description": "Mocks should be declared and initialized in a single line using mockk",
                    "examples": {
                        "compliant": [
                            "private val mockPlayer = mockk<Player>(relaxed = true)",
                            "private val mockChronicle = mockk<GameChronicle>(relaxed = true)"
                        ],
                        "violations": [
                            "private lateinit var mockPlayer: Player",
                            "private val player = mockk<Player>(relaxed = true)"
                        ]
                    }
                },
                "sut_initialization": {
                    "pattern": "private\\s+val\\s+SUT\\s*:\\s*[A-Z]\\w+\\s*=\\s*[A-Z]\\w+\\([^)]+\\)",
                    "description": "Subject Under Test (SUT) should be initialized during declaration",
                    "examples": {
                        "compliant": [
                            "private val SUT: EffectDrawCard = EffectDrawCard(mockCardManager, mockChronicle)",
                            "private val SUT: CombinationGenerator = CombinationGenerator()"
                        ],
                        "violations": [
                            "private lateinit var SUT: EffectDrawCard",
                            "private val sut = EffectDrawCard(mockCardManager, mockChronicle)"
                        ]
                    }
                },
                "mock_naming": {
                    "pattern": "mock[A-Z]\\w+",
                    "description": "Mock variables should be prefixed with 'mock'",
                    "examples": {
                        "compliant": [
                            "private val mockPlayer = mockk<Player>(relaxed = true)",
                            "private val mockChronicle = mockk<GameChronicle>(relaxed = true)"
                        ],
                        "violations": [
                            "private val player = mockk<Player>(relaxed = true)",
                            "private val chronicle = mockk<GameChronicle>(relaxed = true)"
                        ]
                    }
                }
            },
            "applies_to": ["**/*Test.kt"],
            "rationale": "Ensures consistent test setup and improves readability"
        }
    },
    "documentation": {
        "project_scope": {
            "file": "doc/Project.md",
            "description": "Project goals, analysis capabilities, and implementation architecture",
            "required_for": [
                "development scope",
                "simulation requirements",
                "analysis features",
                "success metrics",
                "implementation architecture"
            ]
        },
        "design_principles": {
            "file": "doc/Design.md",
            "description": "Project purpose, game design principles, and analysis priorities",
            "required_for": [
                "implementation decisions",
                "simulation goals",
                "balance testing",
                "success metrics",
                "feature prioritization"
            ]
        },
        "game_rules": {
            "file": "Rules.md",
            "description": "Complete game rules and mechanics documentation",
            "required_for": ["game logic", "card effects", "player interactions"]
        }
    }
}

